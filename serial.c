/*
 * serial.c
 *
 * Copyright (C) 2019 <sgerwk@aol.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * send infrared remote control signals (CIR) via uart
 *
 *        +- - 0.1uF + -+
 * txd ---+-- - led + --+--- 100ohm --- 3.3v
 *
 * led pinout:  - -v- +
 * NOTE: connected between txd and 3.3v, NOT GROUND
 *
 * works at 12cm even when pointed 45degrees away
 * at >60cm requires accurate pointing; works at 150cm
 *
 * how it works 
 * ------------
 *
 * each period of the carrier is generated by a serial output byte; since the
 * led is connected between Vcc and TXD (not between TXD and ground), it is on
 * when TXD is low; byte 0xE0 = 11100000 produces a 50% duty cycle:
 *
 * ---+                       +---+---+---+---+---+---+
 *    |     0   0   0   0   0 | 1   1   1             |
 *    +---+---+---+---+---+---+                       +---
 *   start lsb                         msb par stop stop
 *
 * the carrier cannot be turned off by just not transmitting, since serial port
 * inactivity cannot be timed; instead, byte 0xFF = 11111111 is sent for the
 * appropriate number of times:
 *
 * ---+   +---+---+---+---+---+---+---+---+---+---+---+
 *    |   | 1   1   1   1   1   1   1   1             |
 *    +---+                                           +---
 *   start lsb                         msb par stop stop
 *
 * the led is on only during the start bit; the capacitor is chosen so that it
 * does not charge quickly enough during this isolated start bit to let the led
 * start, but it does for the longer burst above; see below for calculation and
 * actual results
 *
 * timing
 * ------
 *
 * the 38000Hz carrier frequency is obtained by 12 bits at 460800:
 *
 * period, at 38000Hz = 26.3157 microseconds
 * baud 460800 = bit length 2.1701 microseconds
 * 12 serial bits (start+8data+parity+2stop) = 26.0412
 *
 * an idle period between serial output bytes affects the timing; could be
 * taken into account by a command-line parameter to decrease the number of
 * data bits; it is not necessary for the usb-uart adapters tested so far
 *
 * capacitance
 * -----------
 *
 * the optimal value of the capacitance is obtained from the two formulae:
 *	Q = CV
 *	Q = IT
 * where Q=charge, C=capacitance, V=voltage, I=current; in this case, the
 * voltage should go from 0V to 1.2V in about 3microseconds with an average
 * current of 27mA (using the average is not correct in general, but works in
 * this case because the voltage difference 1.2V is small compared to the 3.3V
 * supply); the result is 66nF; the capacitance is more or less linear in time
 * for these values: 22nF for microsecond
 *
 * in practice:
 * - works even without a capacitor, but only at a certain distance (50cm)
 *   where accurate pointing would be required
 * - with a 0.1uF electrolytic capacitor it works even when very close; at
 *   12cm, direction is not a problem since the signal is received even when
 *   pointing the led 45degrees away from the receiver (tested with four
 *   adapters: two ch340g with 4x2 header, a ch340g with cts/rts and a pl2303)
 * - with two parallel 10nF capacitors (20nF), works at close distance only for 
 *   some adapters (the two with 4x2 header) not not all (requires a distance
 *   of 20cm for the cts/rts adapter)
 *
 * testing
 * -------
 *
 * with a device that displays the channel number, test with the channel+ key:
 * it allows testing repeating and does not require waiting like the power key
 * does
 *
 * todo
 * ----
 * - test the other protocols with mic and actual devices
 * - test other frequencies: the best approximation is still 12 bits at 460800
 *   baud; if it does not work, increase baud rate, set 1 stop bit and rely on
 *   a smaller capacitor for cutting both the start and the stop bits
 * - split out serial-main.c, with parameters
 * - use serial.c also for guess.c, which search for the remote codes using the
 *   device only, without the remote: send random and common codes, store the
 *   sequence so that the user can go back
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <sys/stat.h>
#include <stdint.h>
#include <string.h>

/*
 * protocols
 */
enum protocol {
	protocol_nec,
	protocol_nec2,
	protocol_sharp,
	protocol_rc5,
	protocol_sony12,
	protocol_sony15,
	protocol_sony20,
	protocol_test,
	protocol_none
};

/*
 * serial output bytes for carrier and idle
 */
#define BUFSIZE 8192
uint8_t carrier[BUFSIZE];
uint8_t idle[BUFSIZE];

void carrierinit() {
	// carrier duty cycle 6/12, since start+5 bits 0 out of 12
	memset(carrier, 0xE0, BUFSIZE);

	// implement idle as 1/12 duty cycle
	// the start bit cannot be suppressed in software
	memset(idle, 0xFF, BUFSIZE);
}

/*
 * write carrier or idle and increase time
 */
int fwritetime(FILE *fd, uint8_t *buffer, int size, int *time) {
	int res;
	res = fwrite(buffer, size, 1, fd);
	*time += size;
	return res;
}

/*
 * reach a certain duration
 */
void fwritefinish(FILE *fd, uint8_t *buffer, int total, int *time) {
	int slot;
	while (*time < total) {
		slot = total - *time < BUFSIZE ? total - *time : BUFSIZE;
		fwritetime(fd, buffer, slot, time);
	}
}

/*
 * initalize the serial port; call with baud=B460800 except for testing
 */
int serialinit(int fd, int baud) {
	struct termios termios;
	struct stat stat;
	int res;

					/* allow a fifo */
	res = fstat(fd, &stat);
	if (res == -1) {
		perror("stat");
		return -1;
	}
	if (S_ISFIFO(stat.st_mode))
		return 0;

					/* set baudrate and bits */

	res = tcgetattr(fd, &termios);
	if (res == -1) {
		perror("tcgetattr");
		return -1;
	}

	cfmakeraw(&termios);
	cfsetispeed(&termios, baud);
	cfsetospeed(&termios, baud);
	termios.c_cflag |= CS8;			// 8 data bits
	termios.c_cflag |= PARENB;		// parity
	termios.c_cflag |= CMSPAR;		// parity is stick...
	termios.c_cflag |= PARODD;		// ... stick to 1
	termios.c_cflag |= CSTOPB;		// 2 stop bits

	res = tcsetattr(fd, TCSAFLUSH, &termios);
	if (res == -1) {
		perror("tcsetattr");
		return -1;
	}

	return 0;
}

/*
 * translate device/subdevice/function into nec encoding
 */
uint32_t necencoding(int device, int subdevice, int function) {
	uint32_t result;
	 
	if (subdevice == -1)
		subdevice = ~device & 0xFF;

	result = 0;
	result = (result << 8) | (~function & 0xFF);
	result = (result << 8) | (function & 0xFF);
	result = (result << 8) | (subdevice & 0xFF);
	result = (result << 8) | (device & 0xFF);

	return result;
}

/* 
 * send a nec code
 */
void necxsend(FILE *out, uint32_t encoding, int repeat, int subprotocol) {
	int i, time, slot;
	
	time = 0;
	fwritetime(out, carrier, subprotocol == 2 ? 172 : 345, &time);
	if (repeat) {
		fwritetime(out, idle, 86, &time);
		fwritetime(out, carrier, 21, &time);
	}
	else {
		fwritetime(out, idle, 173, &time);
		for (i = 0; i < 32; i++) {
			fwritetime(out, carrier, 21, &time);
			slot = (encoding >> i) & 0x01 ? 65 : 21;
			fwritetime(out, idle, slot, &time);
		}
		fwritetime(out, carrier, 21, &time);
	}
	fwritefinish(out, idle, 4224, &time);
}
void necsend(FILE *out, uint32_t encoding, int repeat) {
	return necxsend(out, encoding, repeat, 1);
}
void nec2send(FILE *out, uint32_t encoding, int repeat) {
	return necxsend(out, encoding, repeat, 2);
}

/*
 * send a sharp code
 */
void sharpsend(FILE *out, uint32_t encoding, int repeat) {
	int i, time, slot;

	(void) repeat;
	
	time = 0;

	encoding |= (1 << 13);
	encoding &= ~(1 << 14);
	encoding |= (1 << 15);

	for (i = 0; i < 16; i++) {
		fwritetime(out, carrier, 12, &time);
		slot = (encoding >> i) & 0x01 ? 65 : 26;
		fwritetime(out, idle, slot, &time);
	}
	fwritetime(out, idle, 1539, &time);

	encoding ^= ~0x001F;

	for (i = 0; i < 16; i++) {
		fwritetime(out, carrier, 12, &time);
		slot = (encoding >> i) & 0x01 ? 65 : 26;
		fwritetime(out, idle, slot, &time);
	}
	fwritetime(out, idle, 1539, &time);
}

/*
 * send a sony20 code
 */
void sony20send(FILE *out, uint32_t encoding, int repeat) {
	int i, j, time, slot;

	(void) repeat;
	
	for (j = 0; j < 3; j++) {
		time = 0;
		fwritetime(out, carrier, 92, &time);
		fwritetime(out, idle, 23, &time);

		for (i = 0; i < 20; i++) {
			slot = (encoding >> i) & 0x01 ? 46 : 23;
			fwritetime(out, carrier, slot, &time);
			fwritetime(out, idle, 23, &time);
		}

		fwritetime(out, idle, 537, &time);
	}
}

/*
 * send an rc5 code
 */
void rc5send(FILE *out, uint32_t encoding, int repeat) {
	int i, j, time;
	static int toggle = 0;

	if (! repeat)
		toggle = ~toggle;

	for (j = 0; j < 2; j++) {
		encoding |= 1 << 12;
		encoding &= ~(1 << 11);
		encoding |= toggle ? (1 << 11) : 0;

		time = 0;

		fwritetime(out, carrier, 34, &time);
		for (i = 12; i >= 0; i--)
			if ((encoding >> i) & 0x01) {
				fwritetime(out, idle, 34, &time);
				fwritetime(out, carrier, 34, &time);
			}
			else {
				fwritetime(out, carrier, 34, &time);
				fwritetime(out, idle, 34, &time);
			}

		fwritefinish(out, idle, 4384, &time);
	}
}

/*
 * usage
 */
void usage() {
	printf("send IR codes to a serial port\n");
	printf("usage:\n");
	printf("\tserial [-a] [-h] [-d (dev|pipe|file)]\n");
	printf("\t       protocol device subdevice function");
	printf(" [times [repetitions]]\n");
	printf("\t\t-a\t\tallow output on arbitrary files\n");
	printf("\t\t-h\t\tthis help\n");
	printf("\t\t-d ...\t\twhere to output:\n");
	printf("\t\t\tdev\ta serial device, like /dev/ttyUSB0\n");
	printf("\t\t\tfifo\ta named pipe, like the one of serial2sound\n");
	printf("\t\t\tfile\tan arbitrary file; allowed only with -a\n");
	printf("\t\tprotocol\tsupported: nec, nec2, rc5, sony20, sharp\n");
	printf("\t\tdevice\t\taddress of device, e.g., $((0x12))\n");
	printf("\t\tsubdevice\textra address of device, e.g., $((0xFB))\n");
	printf("\t\tfunction\tfunction, e.g., $((0x50))\n");
	printf("\t\ttimes\t\tsend the code this many times\n");
	printf("\t\trepetitions\tsend repetitions codes afterwards\n");
}

/*
 * main
 */
int main(int argc, char *argv[]) {
	char *devicename = "/dev/ttyUSB0";
	int opt, allfiles = 0;
	int fd, res;
	FILE *out;
	enum protocol protocol;
	uint32_t device, subdevice, function;
	int nosubdevice;
	int times = 1, rtimes = 0, t;
	uint32_t encoding;

					/* arguments */

	while (-1 != (opt = getopt(argc, argv, "ad:h")))
		switch (opt) {
		case 'a':
			allfiles = 1;
			break;
		case 'd':
			devicename = optarg;
			break;
		case 'h':
			usage();
			exit(EXIT_SUCCESS);
		default:
			usage();
			exit(EXIT_FAILURE);
		}

	if (argc - optind < 3) {
		printf("no argument, using test values\n");
		protocol = protocol_nec;
		device = 0x02;
		subdevice = 0x02;
		nosubdevice = 0;
		function = 0x000A;
		times = 1;
		rtimes = 0;
	}
	else {
		if (! strcmp(argv[optind], "nec"))
			protocol = protocol_nec;
		else if (! strcmp(argv[optind], "nec2"))
			protocol = protocol_nec2;
		else if (! strcmp(argv[optind], "sharp"))
			protocol = protocol_sharp;
		else if (! strcmp(argv[optind], "rc5"))
			protocol = protocol_rc5;
		else if (! strcmp(argv[optind], "sony20"))
			protocol = protocol_sony20;
		else if (! strcmp(argv[optind], "test"))
			protocol = protocol_test;
		else
			protocol = protocol_none;
		device = atoi(argv[optind + 1]);
		subdevice = atoi(argv[optind + 2]);
		nosubdevice = ! strcmp(argv[optind + 2], "none");
		function = atoi(argv[optind + 3]);
		if (argc - optind >= 5)
			times = atoi(argv[optind + 4]);
		if (argc - optind >= 6)
			rtimes = atoi(argv[optind + 5]);
	}

	if (protocol == protocol_none) {
		printf("unsuported protocol\n");
		usage();
		exit(EXIT_FAILURE);
	}
	if (nosubdevice)
		printf("device: 0x%02X function: 0x%04X\n", device, function);
	else
		printf("device: 0x%02X-0x%02X function: 0x%04X\n",
			device, subdevice, function);

					/* open serial port */

	fd = open(devicename, O_WRONLY, 0666);
	if (fd == -1) {
		perror(devicename);
		exit(EXIT_FAILURE);
	}

	out = fdopen(fd, "w");
	if (out == NULL) {
		perror("fdopen");
		exit(EXIT_FAILURE);
	}

					/* initialize carrier */
	
	carrierinit();
	res = serialinit(fd, B460800);
	if (res && ! allfiles) {
		printf("allowed output files are ");
		printf("a. serial devices; and b. fifos (named pipes)\n");
		printf("use -a to allow output to arbitrary files\n");
		exit(EXIT_FAILURE);
	}

					/* testing */

	// slow speed, to check actual waveform
	if (protocol == protocol_test && times & 0x01)
		serialinit(fd, B9600);

	// test the carrier: send 1 - 0 - 1
	if (protocol == protocol_test && times & 0x02) {
		fwrite(carrier, 50, 1, out);
		fwrite(idle, 50, 1, out);
		fwrite(carrier, 50, 1, out);
		return EXIT_SUCCESS;
	}

					/* send codes */

	for (t = 0; t < times + rtimes; t++)
		switch (protocol) {
		case protocol_nec:
			encoding = nosubdevice ?
				necencoding(device, -1, function) :
				necencoding(device, subdevice, function);
			necsend(out, encoding, t >= times);
			break;
		case protocol_nec2:
			encoding = nosubdevice ?
				necencoding(device, -1, function) :
				necencoding(device, subdevice, function);
			nec2send(out, encoding, t >= times);
			break;
		case protocol_sharp:
			encoding = 0;
			encoding |= (function & 0xFF) << 5;
			encoding |= device & 0x1F;
			sharpsend(out, encoding, t >= times);
			break;
		case protocol_sony12:
			break;
		case protocol_sony15:
			break;
		case protocol_sony20:
			encoding = (subdevice << 12) | (device << 7) | function;
			sony20send(out, encoding, t >= times);
			break;
		case protocol_rc5:
			encoding = 0;
			encoding |= (device & 0x1F) << 6;
			encoding |= function & 0x3F;
			rc5send(out, encoding, t >= times);
			break;
		case protocol_test:
		case protocol_none:
			break;
		}

					/* end */

	fflush(out);
	fclose(out);

	return EXIT_SUCCESS;
}

